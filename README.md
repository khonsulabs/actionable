# actionable

The goal of this crate is to provide a way to derive an async-based API-dispatcher that can help handle permissions for you.

This permissions system will be the permissions system utilized in [PliantDb][pliantdb], and the API system will drive the internal API as well as an exposable API platform within PliantDb.

This readme is temporary documentation/vision.

## Permissions

The `Permissions` struct is constructed from a list of `Statement`s. The `Statement` struct is inspired by [statements in IAM](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_policies_elements_statement.html). By default, all actions are denied for all resources.

The `ResourceName` struct describes a unique name/id of *anything* in your application. This is meant to be similar to [ARNs in IAM](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_identifiers.html#identifiers-arns), but instead of being restricted to a format by this library, you are able to define your own syntax.

The `Action` trait is derive-able, and will convert any enum to something that can be permitted or denied to any `ResourceName`. This derive macro only supports enums with variants that have no parameters, or only have a single name-less parameter that also implements `Action`.

An example `Action` enum might look like:

```rust
#[derive(Action, Debug)]
pub enum AllActions {
    FlushCache,
    User(UserActions)
}

#[derive(Action, Debug)]
pub enum UserActions {
    Create,
    ChangeUsername,
    Delete,
}
```

An example permissions check for `users.42` might look like:

```rust
let allowed = permissions.allowed_to(
    &Resource::named("users").and(42), 
    &AllActions::User(UserActions::Delete)
);
```

## Permissable async API

At the core of many network APIs written in Rust is an enum that represents a request, and similarly there are usually common response/error types. In these applications, there is usually a manually-written match statement that, for readability and maintainability, simply pass the parameters from the request to a helper method to handle the actual logic of the request.

The goal of the API portion of this crate is to replace this boilerplate with a simple derive macro. For example:

```rust
#[derive(Actionable, Debug)]
pub enum Request {
    /// An unprotected API request with no permissions checks
    GetPublicData,

    /// A protected API request that requires implementing an 
    /// `is_allowed()` method in the handler.
    #[actionable(protection = "custom")]
    FlushCache(u64),

    /// A protected API request that requires implementing `resource_name(&str) -> ResourceName` and `action() -> Action` in the handler.
    #[actionable(protection = "simple")]
    CreateUser { username: String },
}
```

This derive also generates several traits:

```rust
// These traits are auto-generated by #[derive(Actionable)]
#[async_trait]
pub trait RequestDispatcher: Send + Sync {
    type Output: Send + Sync;
    type Error: From<actionable::PermissionDenied> + Send + Sync;

    type GetPublicDataHandler: GetPublicDataHandler<Dispatcher = Self>;
    type FlushCacheHandler: FlushCacheHandler<Dispatcher = Self>;
    type CreateUserHandler: CreateUserHandler<Dispatcher = Self>;
    
    async fn act(
            &self,
            request: Request,
            permissions: &actionable::Permissions,
    ) -> Result<Self::Output, Self::Error> {
        // the match is implemented for you
    }
}

#[async_trait]
pub trait GetPublicDataHandler {
    type Dispatcher: RequestDispatcher;

    async fn handle(dispatcher: &Self::Dispatcher) ->
        Result<
            <Self::Dispatcher as RequestDispatcher>::Output,
            <Self::Dispatcher as RequestDispatcher>::Error,
        >;
}

#[async_trait]
pub trait FlushCacheHandler {
    type Dispatcher: RequestDispatcher;

    fn is_allowed(permissions: &actionable::Permissions, arg1: &u64) -> bool;

    async fn handle_protected(dispatcher: &Self::Dispatcher, arg1: u64) ->
        Result<
            <Self::Dispatcher as RequestDispatcher>::Output,
            <Self::Dispatcher as RequestDispatcher>::Error,
        >;
}

#[async_trait]
pub trait CreateUserHandler {
    type Dispatcher: RequestDispatcher;
    type Action: actionable::Action;

    fn resource_name(username: &str) -> ResourceName;
    fn action() -> Action;

    async fn handle_protected(dispatcher: &Self::Dispatcher, username: String) ->
        Result<
            <Self::Dispatcher as RequestDispatcher>::Output,
            <Self::Dispatcher as RequestDispatcher>::Error,
        >;
}

```

To implement the API, you would implement each of the `Handler` traits, as well as the `RequestDispatcher` trait:

```rust
// You could store application state on this object
pub struct Dispatcher;

impl RequestDispatcher for Dispatcher {
    type Output = ();
    type Error = anyhow::Error;

    // These types could be independent if you wanted more modularity.
    type GetPublicDataHandler = Self;
    type FlushCacheHandler = Self;
    type CreateUserHandler = Self;
}

impl GetPublicDataHandler for Dispatcher {
    type Dispatcher: Self;

    async fn handle(dispatcher: &Dispatcher) -> Result<(), anyhow::Error> {
        /// return the public data.
        Ok(())
    }
}

impl FlushCacheHandler for Dispatcher {
    type Dispatcher: Self;

    fn is_allowed(permissions: &actionable::Permissions, cache_key: &u64) -> bool {
        // If you needed more complex permissions checking, you can implement it here
        permissions.is_allowed(&Resource::named("cache").and(cache_key), AllActions::FlushCache)
    }

    async fn handle_protected(dispatcher: &Dispatcher, cache_key: u64) -> Result<(), anyhow::Error> {
        todo!("Flush the cache!")
    }
}

impl CreateUserHandler for Dispatcher {
    type Dispatcher: Self;

    fn resource_name(_username: &str) -> ResourceName {
        Resource::named("user")
    }

    fn action() -> Action {
        AllActions::User(UserActions::Create)
    }

    async fn handle_protected(dispatcher: &Dispatcher, username: String) -> Result<(), anyhow::Error> {
        todo!("Insert the user!")
    }
}
```

[pliantdb]: https://github.com/khonsulabs/pliantdb
